import { WebSocketService } from './services/api';
import { VisualizationService } from './services/visualization';
import * as Types from './types';
import './styles/global.css';

export class PacketViewApp {
  private wsService: WebSocketService;
  private vizService: VisualizationService;
  private interfaces: Types.InterfaceInfo[] = [];
  private selectedInterfaces: string[] = [];
  private interfaceMode: 'single' | 'multiple' = 'single';
  private isCapturing: boolean = false;

  private controlPanelElement: HTMLElement;
  private statsPanelElement: HTMLElement;
  private deviceTooltipElement: HTMLElement;

  private totalPackets: number = 0;
  private totalTraffic: number = 0;

  constructor() {
    this.wsService = new WebSocketService('');

    const canvas = document.createElement('canvas');
    canvas.id = 'canvas-container';
    const vizContainer = document.getElementById('visualization');
    if (vizContainer) {
      vizContainer.appendChild(canvas);
    }
    this.vizService = new VisualizationService(canvas);

    this.controlPanelElement = this.createControlPanel();
    this.statsPanelElement = this.createStatsPanel();
    this.deviceTooltipElement = this.createDeviceTooltip();

    document.body.appendChild(this.controlPanelElement);
    document.body.appendChild(this.statsPanelElement);
    document.body.appendChild(this.deviceTooltipElement);

    this.setupWebSocketHandlers();
    this.setupEventListeners();
    this.loadInterfaces();
  }

  private createControlPanel(): HTMLElement {
    const panel = document.createElement('div');
    panel.className = 'control-panel';
    panel.innerHTML = `
      <h2>PacketView</h2>
      <div class="section">
        <label for="interface-select">Network Interfaces</label>
        <div id="interface-checkboxes" class="interface-checkboxes"></div>
      </div>
      <div class="section filter-section">
        <h3>Live Filters</h3>
        <div class="filter-row">
          <label for="ip-filter">IP Address:</label>
          <input type="text" id="ip-filter" placeholder="e.g., 192.168" />
        </div>
        <div class="filter-row">
          <label for="ip-type-filter">IP Type:</label>
          <select id="ip-type-filter">
            <option value="all">All IPs</option>
            <option value="local">Local Only</option>
            <option value="public">Public Only</option>
          </select>
        </div>
        <div class="filter-row">
          <label for="protocol-filter">Protocol:</label>
          <select id="protocol-filter">
            <option value="all">All Protocols</option>
            <option value="TCP">TCP</option>
            <option value="UDP">UDP</option>
            <option value="ICMP">ICMP</option>
            <option value="HTTP">HTTP</option>
            <option value="HTTPS">HTTPS</option>
            <option value="DNS">DNS</option>
            <option value="SSH">SSH</option>
            <option value="FTP">FTP</option>
            <option value="SMTP">SMTP</option>
          </select>
        </div>
        <div class="filter-row">
          <label for="interface-filter">Interface:</label>
          <select id="interface-filter">
            <option value="all">All Interfaces</option>
          </select>
        </div>
        <div class="filter-row">
          <label for="broadcast-filter" class="checkbox-label">
            <input type="checkbox" id="broadcast-filter" />
            Show Broadcast/Multicast
          </label>
        </div>
      </div>
       <button id="reset-view-btn">Reset View</button>
       <button id="toggle-animations-btn">Disable Animations</button>
       <div class="status inactive" id="status-panel">
         Status: <span id="status-text">Connecting...</span>
       </div>
    `;
    return panel;
  }

  private createStatsPanel(): HTMLElement {
    const panel = document.createElement('div');
    panel.className = 'stats-panel';
    panel.innerHTML = `
      <h3>Statistics</h3>
      <div class="stat">
        <span class="label">Total Packets:</span>
        <span class="value" id="total-packets">0</span>
      </div>
      <div class="stat">
        <span class="label">Total Traffic:</span>
        <span class="value" id="total-traffic">0 B</span>
      </div>
      <div class="stat">
        <span class="label">Active Devices:</span>
        <span class="value" id="active-devices">0</span>
      </div>
      <div class="stat">
        <span class="label">Active Connections:</span>
        <span class="value" id="active-connections">0</span>
      </div>
    `;
    return panel;
  }

  private createDeviceTooltip(): HTMLElement {
    const tooltip = document.createElement('div');
    tooltip.className = 'device-tooltip';
    tooltip.style.display = 'none';
    return tooltip;
  }

  private setupEventListeners(): void {
    const resetViewBtn = document.getElementById('reset-view-btn') as HTMLButtonElement;
    const ipFilterInput = document.getElementById('ip-filter') as HTMLInputElement;
    const ipTypeFilterSelect = document.getElementById('ip-type-filter') as HTMLSelectElement;
    const protocolFilterSelect = document.getElementById('protocol-filter') as HTMLSelectElement;
    const broadcastFilterCheckbox = document.getElementById('broadcast-filter') as HTMLInputElement;
    const interfaceFilter = document.getElementById('interface-filter') as HTMLSelectElement;

    const updateFilters = () => {
      this.vizService.setFilters({
        ip: ipFilterInput.value.trim(),
        ipType: ipTypeFilterSelect.value as 'all' | 'local' | 'public',
        protocol: protocolFilterSelect.value === 'all' ? 'all' : protocolFilterSelect.value as Types.Protocol,
        broadcast: broadcastFilterCheckbox.checked,
        interface: interfaceFilter.value
      });
    };

    ipFilterInput.addEventListener('input', updateFilters);
    ipTypeFilterSelect.addEventListener('change', updateFilters);
    protocolFilterSelect.addEventListener('change', updateFilters);
    broadcastFilterCheckbox.addEventListener('change', updateFilters);
    interfaceFilter.addEventListener('change', updateFilters);

    resetViewBtn.addEventListener('click', () => this.vizService.resetView());
    document.getElementById('toggle-animations-btn')?.addEventListener('click', () => {
      const isEnabled = this.vizService.togglePacketAnimations();
      const btn = document.getElementById('toggle-animations-btn') as HTMLButtonElement;
      btn.textContent = isEnabled ? 'Disable Animations' : 'Enable Animations';
    });

    document.addEventListener('mousemove', (e) => this.handleMouseMove(e));

    this.vizService.start();
  }

  private setupWebSocketHandlers(): void {
    this.wsService.onMessage(Types.WebSocketMessageType.INTERFACE_LIST, (interfaces: Types.InterfaceInfo[]) => {
      this.interfaces = interfaces;
      console.log(`[Frontend] Received ${interfaces.length} network interfaces`);
    });

    this.wsService.onMessage(Types.WebSocketMessageType.PACKET, (packet: Types.Packet) => {
      this.totalPackets++;
      this.totalTraffic += packet.size;
      this.updateStats();

    this.updateCaptureStatus(packet);
    }

    private updateCaptureStatus(packet: Types.Packet): void {
      if (packet.interface) {
        const checkbox = document.getElementById(`iface-${packet.interface}`) as HTMLInputElement;
        if (checkbox && !checkbox.checked) {
          checkbox.checked = true;
        }
      }
    }

    this.wsService.onMessage(Types.WebSocketMessageType.NETWORK_STATE, (state: Types.NetworkState) => {
      const devices = state.devices ? Array.from(state.devices.values()) : [];
      const connections = state.connections ? Array.from(state.connections.values()) : [];

      this.vizService.updateNetworkState(devices, connections);

      const activeDevicesEl = document.getElementById('active-devices');
      const activeConnectionsEl = document.getElementById('active-connections');
      if (activeDevicesEl) activeDevicesEl.textContent = devices.length.toString();
      if (activeConnectionsEl) activeConnectionsEl.textContent = connections.length.toString();

      if (devices.length > 0 && this.totalPackets % 100 === 0) {
        console.log(`[Frontend] Network state: ${devices.length} devices, ${connections.length} connections`);
      }
    });

    this.wsService.onMessage(Types.WebSocketMessageType.ERROR, (error: any) => {
      console.error('[Frontend] Server error:', error);
      alert(`Error: ${error.error}`);
    });

    this.wsService.connect();
  }

  private async loadInterfaces(): Promise<void> {
    try {
      const response = await fetch('/api/interfaces');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      this.interfaces = data.interfaces;
      console.log('Loaded interfaces:', this.interfaces);
    } catch (error) {
      console.error('Failed to load interfaces:', error);
      this.showErrorMessage('Failed to load network interfaces. Make sure backend is running on port 3001.');
    }
  }

  private showErrorMessage(message: string): void {
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 68, 68, 0.9);
      color: white;
      padding: 20px 30px;
      border-radius: 8px;
      z-index: 9999;
      text-align: center;
      max-width: 400px;
    `;
    errorDiv.textContent = message;
    document.body.appendChild(errorDiv);

    setTimeout(() => {
      document.body.removeChild(errorDiv);
    }, 5000);
  }
  
  private setupWebSocketHandlers(): void {
    this.interfaceMode = mode;
    const singleMode = document.getElementById('single-interface-mode') as HTMLDivElement;
    const multiMode = document.getElementById('multiple-interface-mode') as HTMLDivElement;
    
    if (mode === 'single') {
      singleMode.style.display = 'block';
      multiMode.style.display = 'none';
      
      // Set selected interfaces to the single interface selection
      const singleSelect = document.getElementById('interface-select') as HTMLSelectElement;
      if (singleSelect.value) {
        this.selectedInterfaces = [singleSelect.value];
      }
    } else {
      singleMode.style.display = 'none';
      multiMode.style.display = 'block';
      
      // Keep current selected interfaces or clear if empty
      if (this.selectedInterfaces.length === 0) {
        const upInterfaces = this.interfaces.filter(iface => iface.isUp);
        this.selectedInterfaces = upInterfaces.slice(0, 1).map(iface => iface.name);
      }
    }
    
    this.updateStartButton();
  }

  private updateSelectedInterfaces(): void {
    const checkboxes = document.querySelectorAll('#interface-checkboxes input[type="checkbox"]:checked');
    this.selectedInterfaces = Array.from(checkboxes).map((cb: any) => cb.value);
    this.updateStartButton();
  }

  private updateStartButton(): void {
    const startBtn = document.getElementById('start-capture-btn') as HTMLButtonElement;
    const stopBtn = document.getElementById('stop-capture-btn') as HTMLButtonElement;

    const hasSelectedInterfaces = this.selectedInterfaces.length > 0;
    startBtn.disabled = !hasSelectedInterfaces || this.isCapturing;
    stopBtn.disabled = !this.isCapturing;
  }

  private async startCapture(): Promise<void> {
    if (this.selectedInterfaces.length === 0) {
      this.showErrorMessage('Please select at least one network interface.');
      return;
    }

    console.log(`[Frontend] Starting capture on interfaces: ${this.selectedInterfaces.join(', ')}`);

    try {
      const requestBody: any = {};
      if (this.interfaceMode === 'single') {
        requestBody.interface = this.selectedInterfaces[0];
      } else {
        requestBody.interfaces = this.selectedInterfaces;
      }

      const response = await fetch('/api/capture/start', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Server error: ${errorText}`);
      }

      this.isCapturing = true;
      this.updateStatus('Capturing', true);
      this.updateStartButton();
      console.log('[Frontend] Capture started successfully');
    } catch (error: any) {
      console.error('[Frontend] Failed to start capture:', error);
      this.showErrorMessage(`Failed to start capture: ${error.message || error}`);
      this.isCapturing = false;
      this.updateStartButton();
    }
  }

  private async stopCapture(): Promise<void> {
    console.log('[Frontend] Stopping capture...');

    try {
      const response = await fetch('/api/capture/stop', {
        method: 'POST'
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Server error: ${errorText}`);
      }

      this.isCapturing = false;
      this.updateStatus('Idle', false);
      this.updateStartButton();
      console.log(`[Frontend] Capture stopped successfully. Total stats: ${this.totalPackets} packets, ${this.formatBytes(this.totalTraffic)} traffic`);
    } catch (error: any) {
      console.error('[Frontend] Failed to stop capture:', error);
      this.showErrorMessage(`Failed to stop capture: ${error.message || error}`);
    }
  }

  private updateStatus(text: string, active: boolean): void {
    const statusPanel = document.getElementById('status-panel') as HTMLElement;
    const statusText = document.getElementById('status-text') as HTMLElement;

    statusPanel.className = `status ${active ? 'active' : 'inactive'}`;
    statusText.textContent = text;
  }

  private updateStats(): void {
    const totalPacketsEl = document.getElementById('total-packets');
    const totalTrafficEl = document.getElementById('total-traffic');

    if (totalPacketsEl) totalPacketsEl.textContent = this.totalPackets.toString();
    if (totalTrafficEl) totalTrafficEl.textContent = this.formatBytes(this.totalTraffic);
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
  }

  private handleMouseMove(event: MouseEvent): void {
    const canvas = document.getElementById('canvas-container') as HTMLCanvasElement;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    this.vizService.updateCursor(x, y);
    const device = this.vizService.getDeviceAtPosition(x, y);

    if (device) {
      const totalBytes = device.trafficIn + device.trafficOut;
      if (this.totalPackets % 100 === 0) {
        console.log(`[Frontend] Hovering over device ${device.ip}: Type=${device.type}, In=${this.formatBytes(device.trafficIn)}, Out=${this.formatBytes(device.trafficOut)}, Total=${this.formatBytes(totalBytes)}`);
      }
      this.deviceTooltipElement.style.display = 'block';
      this.deviceTooltipElement.style.left = `${event.clientX + 15}px`;
      this.deviceTooltipElement.style.top = `${event.clientY + 15}px`;
      this.deviceTooltipElement.innerHTML = `
        <h3>${device.ip}</h3>
        <div class="info"><strong>Type:</strong> ${device.type}</div>
        <div class="info"><strong>Traffic In:</strong> ${this.formatBytes(device.trafficIn)}</div>
        <div class="info"><strong>Traffic Out:</strong> ${this.formatBytes(device.trafficOut)}</div>
        <div class="info"><strong>Total Traffic:</strong> ${this.formatBytes(totalBytes)}</div>
        ${device.hostname ? `<div class="info"><strong>Hostname:</strong> ${device.hostname}</div>` : ''}
      `;
    } else {
      this.deviceTooltipElement.style.display = 'none';
    }
  }
}

new PacketViewApp();
